<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document Interaction</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background-color: #f4f4f4;
    }

    .container {
      display: flex;
      flex: 1;
      overflow: hidden;
      /* Prevent overall page scroll */
    }

    .sidebar {
      width: 250px;
      background-color: #e9e9e9;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      border-right: 1px solid #ccc;
    }

    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      background-color: #fff;
      overflow: hidden;
      /* Prevent main content scroll */
    }

    .chat-area {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      /* Allow chat area to scroll */
      border-bottom: 1px solid #ccc;
    }

    .input-area {
      display: flex;
      padding: 15px;
      border-top: 1px solid #ccc;
      background-color: #f9f9f9;
    }

    .input-area input[type="text"] {
      flex: 1;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-right: 10px;
    }

    .input-area button {
      padding: 10px 15px;
      border: none;
      background-color: #007bff;
      color: white;
      border-radius: 4px;
      cursor: pointer;
    }

    .input-area button:hover {
      background-color: #0056b3;
    }

    .message {
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 5px;
    }

    .message.user {
      background-color: #e1f5fe;
      text-align: right;
      margin-left: auto;
      max-width: 70%;
    }

    .message.bot {
      background-color: #f1f1f1;
      text-align: left;
      margin-right: auto;
      max-width: 70%;
      white-space: pre-wrap;
      /* Preserve whitespace and line breaks */
    }

    .upload-section,
    .query-section {
      margin-bottom: 20px;
    }

    .upload-section h3,
    .query-section h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #333;
    }

    .upload-section input[type="file"] {
      margin-bottom: 10px;
    }

    #upload-status,
    #query-result {
      margin-top: 10px;
      padding: 10px;
      background-color: #eee;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9em;
      white-space: pre-wrap;
      max-height: 200px;
      overflow-y: auto;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        height: auto;
        max-height: 30vh;
        /* Limit sidebar height on small screens */
        border-right: none;
        border-bottom: 1px solid #ccc;
      }

      .main-content {
        flex: 1;
        /* Take remaining height */
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="sidebar">
      <div class="upload-section">
        <h3>Upload Document</h3>
        <div>
          <label for="upload-index-name" style="display: block; margin-bottom: 5px;">Index Name:</label>
          <input type="text" id="upload-index-name" placeholder="Enter index name (optional)"
            style="width: calc(100% - 22px); padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 10px;">
        </div>
        <input type="file" id="file-input" accept=".doc,.docx,.pdf">
        <button id="upload-button">Upload</button>
        <div id="upload-status" style="display: none;"></div>
      </div>
      <hr>
      <div class="index-selection-section" style="margin-bottom: 20px;">
        <h3>Select Index</h3>
        <select id="index-name-select" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
          <option value="visa_demo" selected>visa_demo</option>
          <option value="child_english">child_english</option>
          <option value="devops">devops</option>
        </select>
      </div>
    </div>
    <div class="main-content">
      <div class="chat-area" id="chat-area">
        <!-- Chat messages will appear here -->
        <div class="message bot">Hello! Upload a document or ask me a question.</div>
      </div>
      <div class="input-area">
        <input type="text" id="chat-input" placeholder="Type your message...">
        <button id="send-button">Send</button>
      </div>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('file-input');
    const uploadButton = document.getElementById('upload-button');
    const uploadStatus = document.getElementById('upload-status');
    const chatArea = document.getElementById('chat-area');
    const chatInput = document.getElementById('chat-input');
    const sendButton = document.getElementById('send-button');

    // --- File Upload Logic ---
    uploadButton.addEventListener('click', async () => {
      const file = fileInput.files[0];
      if (!file) {
        alert('Please select a file first.');
        return;
      }

      uploadStatus.textContent = 'Uploading...';
      uploadStatus.style.display = 'block';
      chatArea.innerHTML = ''; // Clear chat area for potentially streamed markdown

      const formData = new FormData();
      const indexNameInput = document.getElementById('upload-index-name');
      const index_name = indexNameInput.value.trim();

      // Set the index name in the dropdown and select it
      if (index_name) {
        const indexNameSelect = document.getElementById('index-name-select');
        let optionExists = false;
        // Check if the option already exists
        for (let i = 0; i < indexNameSelect.options.length; i++) {
          if (indexNameSelect.options[i].value === index_name) {
            optionExists = true;
            break;
          }
        }
        // If the option doesn't exist, create and add it
        if (!optionExists) {
          const newOption = document.createElement('option');
          newOption.value = index_name;
          newOption.textContent = index_name;
          indexNameSelect.appendChild(newOption);
        }
        // Set the select element's value to the new index name
        indexNameSelect.value = index_name;
      }

      formData.append('file', file);
      // NOTE: index_name is sent as a query parameter, not in FormData body

      try {
        // Construct the URL with index_name as a query parameter if provided
        let uploadUrl = '/api/upload';
        if (index_name) {
          uploadUrl += `?index_name=${encodeURIComponent(index_name)}`;
        }

        const response = await fetch(uploadUrl, { // Use the potentially modified URL
          method: 'POST',
          body: formData, // FormData still contains the file
        });

        uploadStatus.textContent = `Status: ${response.status} ${response.statusText}`;

        if (!response.ok) {
          const errorText = await response.text();
          uploadStatus.textContent += `\nError: ${errorText}`;
          addMessage('bot', `Upload failed: ${errorText}`);
          return;
        }

        // Handle PDF success message
        if (file.name.toLowerCase().endsWith('.pdf')) {
          const successText = await response.text();
          uploadStatus.textContent += `\n${successText}`;
          addMessage('bot', successText); // Show success in chat too
          return; // Nothing more to stream for PDF
        }

        // Handle streamed response for DOC/DOCX
        if (response.headers.get('Content-Type')?.includes('text/event-stream')) {
          uploadStatus.textContent += '\nStreaming Markdown...';
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let markdownContent = '';
          let botMessageDiv = addMessage('bot', 'Processing document...'); // Add initial message

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });

            // Assuming the stream sends markdown directly
            markdownContent += chunk;
            botMessageDiv.textContent = markdownContent; // Update message content
            chatArea.scrollTop = chatArea.scrollHeight; // Scroll down
          }
          uploadStatus.textContent += '\nStreaming complete.';
          // Final update just in case
          botMessageDiv.textContent = markdownContent;
          chatArea.scrollTop = chatArea.scrollHeight;

        } else {
          // Fallback for non-streamed success (shouldn't happen based on Python code)
          const text = await response.text();
          uploadStatus.textContent += `\nResponse: ${text}`;
          addMessage('bot', text);
        }

      } catch (error) {
        console.error('Upload error:', error);
        uploadStatus.textContent = `Upload failed: ${error.message}`;
        addMessage('bot', `Upload failed: ${error.message}`);
      } finally {
        fileInput.value = ''; // Clear file input
      }
    });

    // --- Chat Logic ---
    sendButton.addEventListener('click', handleSendMessage);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        handleSendMessage();
      }
    });

    async function handleSendMessage() {
      const prompt = chatInput.value.trim();
      if (!prompt) return;

      // Get the selected index name
      const indexNameSelect = document.getElementById('index-name-select');
      const index_name = indexNameSelect.value;

      addMessage('user', prompt);
      chatInput.value = '';
      let botMessageDiv = addMessage('bot', '...'); // Placeholder for bot response

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ prompt: prompt, index_name: index_name }), // Use selected index name
        });

        if (!response.ok) {
          const errorText = await response.text();
          botMessageDiv.textContent = `Error: ${errorText}`;
          throw new Error(`Network response was not ok: ${response.statusText}`);
        }

        // Handle Server-Sent Events (SSE)
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let accumulatedResponse = "";

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          // Simple handling: append chunk to message
          // Assumes server sends plain text chunks directly
          content = JSON.parse(chunk)
          console.log(content)
          accumulatedResponse += content.content;
          botMessageDiv.textContent = accumulatedResponse; // Update the bot message div
          chatArea.scrollTop = chatArea.scrollHeight; // Keep scrolled to bottom
        }
        // Final update just in case
        botMessageDiv.textContent = accumulatedResponse;
        chatArea.scrollTop = chatArea.scrollHeight;


      } catch (error) {
        console.error('Chat error:', error);
        if (botMessageDiv) {
          botMessageDiv.textContent = `Error fetching response: ${error.message}`;
        } else {
          addMessage('bot', `Error fetching response: ${error.message}`);
        }
      }
    }

    function addMessage(sender, text) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', sender);
      messageDiv.textContent = text;
      chatArea.appendChild(messageDiv);
      chatArea.scrollTop = chatArea.scrollHeight; // Scroll to the bottom
      return messageDiv; // Return the created div for potential updates
    }

    // --- Query Logic (Placeholder) ---
    /*
    queryButton.addEventListener('click', async () => {
        const prompt = queryPrompt.value.trim();
        const indexName = queryIndex.value.trim() || "child_english"; // Default if empty

        if (!prompt) {
            alert('Please enter a query prompt.');
            return;
        }

        queryResult.textContent = 'Querying...';
        queryResult.style.display = 'block';

        try {
            const response = await fetch(`/api/query?prompt=${encodeURIComponent(prompt)}&index_name=${encodeURIComponent(indexName)}`);
            queryResult.textContent = `Status: ${response.status} ${response.statusText}\n`;

            if (!response.ok) {
                const errorText = await response.text();
                queryResult.textContent += `Error: ${errorText}`;
            } else {
                const data = await response.json();
                queryResult.textContent += `Result:\n${JSON.stringify(data.result, null, 2)}`;
            }
        } catch (error) {
            console.error('Query error:', error);
            queryResult.textContent = `Query failed: ${error.message}`;
        }
    });
    */

  </script>
</body>

</html>